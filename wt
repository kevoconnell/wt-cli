#!/usr/bin/env zsh
# ==============================================================================
# wt - Git Worktree Manager
# ==============================================================================
# A simple CLI for managing git worktrees in a structured workflow.
# Worktrees are stored in ../<repo-name>-worktrees/<name> relative to the repo.
#
# Usage: wt <command> [args]
#
# Commands:
#   new <name>   Create a new worktree and branch from origin/main
#   rm <name>    Remove a worktree and its local branch
#   ls           List all worktrees
#   prune        Prune stale worktree metadata
#   cd <name>    Print the path to a worktree (use with: cd "$(wt cd name)")
#   help         Show this help message
# ==============================================================================

# ------------------------------------------------------------------------------
# Script settings - fail fast on errors
# ------------------------------------------------------------------------------
set -e  # Exit on error
set -u  # Error on undefined variables

# ------------------------------------------------------------------------------
# Configuration
# ------------------------------------------------------------------------------
readonly BASE_BRANCH="origin/main"   # Branch to base new worktrees on
readonly WT_DIR_SUFFIX="-worktrees"  # Suffix for worktrees directory (e.g., repo-worktrees)

# ------------------------------------------------------------------------------
# Helper Functions
# ------------------------------------------------------------------------------

# Print an error message and exit with status 1
die() {
    echo "error: $1" >&2
    exit 1
}

# Print an info message to stderr (so it doesn't interfere with stdout for cd)
info() {
    echo "$1" >&2
}

# Check if we're inside a git repository
validate_git_repo() {
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        die "not a git repository (or any of the parent directories)"
    fi
}

# Get the root directory of the current git repository
get_repo_root() {
    git rev-parse --show-toplevel
}

# Get the base directory where worktrees are stored (../<repo-name>-worktrees)
get_wt_base() {
    local repo_root="$1"
    local repo_name="${repo_root:t}"
    echo "${repo_root:h}/${repo_name}${WT_DIR_SUFFIX}"
}

# Validate that a worktree name is provided and valid
validate_name() {
    local name="$1"

    if [[ -z "$name" ]]; then
        die "worktree name is required"
    fi

    # Check for invalid characters (basic validation)
    if [[ "$name" =~ [[:space:]] ]]; then
        die "worktree name cannot contain spaces"
    fi

    if [[ "$name" == "." || "$name" == ".." ]]; then
        die "invalid worktree name: $name"
    fi
}

# Check if a local branch exists
branch_exists() {
    git show-ref --verify --quiet "refs/heads/$1" 2>/dev/null
}

# ------------------------------------------------------------------------------
# Command: new
# ------------------------------------------------------------------------------
# Create a new worktree with a branch based on origin/main
cmd_new() {
    local name="${1:-}"
    validate_name "$name"

    local repo_root
    repo_root="$(get_repo_root)"

    local wt_base
    wt_base="$(get_wt_base "$repo_root")"

    local target_path="${wt_base}/${name}"

    # Check if worktree directory already exists
    if [[ -d "$target_path" ]]; then
        die "worktree already exists at: $target_path"
    fi

    # Check if branch already exists
    if branch_exists "$name"; then
        die "branch '$name' already exists"
    fi

    # Fetch latest from origin to ensure we have up-to-date main
    info "Fetching from origin..."
    git fetch origin main

    # Create the worktree base directory if it doesn't exist
    mkdir -p "$wt_base"

    # Create the worktree with a new branch
    info "Creating worktree at: $target_path"
    git worktree add -b "$name" "$target_path" "$BASE_BRANCH"

    # Push the branch to remote and set up tracking
    info "Pushing branch to origin..."
    git -C "$target_path" push -u origin "$name"

    # Copy .env if it exists in repo root and not in target
    local env_source="${repo_root}/.env"
    local env_target="${target_path}/.env"

    if [[ -f "$env_source" && ! -f "$env_target" ]]; then
        info "Copying .env to worktree..."
        cp "$env_source" "$env_target"
    fi

    # Open in VS Code if available
    if command -v code &>/dev/null; then
        info "Opening in VS Code..."
        code "$target_path"
    fi

    # Print the path for the user to cd into
    info ""
    info "Worktree created successfully!"
    info "To navigate there, run:"
    info "  cd \"$target_path\""

    # Also print just the path to stdout for scripting: cd "$(wt new name)"
    echo "$target_path"
}

# ------------------------------------------------------------------------------
# Command: rm
# ------------------------------------------------------------------------------
# Remove a worktree and its local branch
cmd_rm() {
    local name="${1:-}"
    validate_name "$name"

    local repo_root
    repo_root="$(get_repo_root)"

    local wt_base
    wt_base="$(get_wt_base "$repo_root")"

    local target_path="${wt_base}/${name}"

    # Check if we're currently inside the worktree we're trying to delete
    local current_dir
    current_dir="$(pwd)"

    # Resolve to absolute paths for comparison
    local resolved_target
    resolved_target="$(cd "$target_path" 2>/dev/null && pwd)" || resolved_target=""

    if [[ -n "$resolved_target" && "$current_dir" == "$resolved_target"* ]]; then
        die "cannot remove worktree while inside it. Please cd elsewhere first."
    fi

    # Check if worktree exists
    if [[ ! -d "$target_path" ]]; then
        die "worktree not found at: $target_path"
    fi

    # Get the branch name from git worktree list (it's in brackets, may differ from folder name)
    local branch_name
    branch_name=$(git worktree list --porcelain | grep -A2 "worktree $target_path$" | grep "^branch " | sed 's/^branch refs\/heads\///')

    # Remove the worktree
    info "Removing worktree at: $target_path"
    git worktree remove "$target_path"

    # Try to delete the local branch using the actual branch name
    if [[ -n "$branch_name" ]] && branch_exists "$branch_name"; then
        info "Deleting local branch: $branch_name"

        # Try safe delete first (-d), fall back to force delete (-D) if unmerged
        if ! git branch -d "$branch_name" 2>/dev/null; then
            info "Warning: branch has unmerged changes, force deleting..."
            git branch -D "$branch_name"
        fi
    fi

    # Prune any stale worktree metadata
    git worktree prune

    info "Worktree '$name' removed successfully."
}

# ------------------------------------------------------------------------------
# Command: ls
# ------------------------------------------------------------------------------
# List all worktrees with interactive selection via fzf
cmd_ls() {
    # Check if fzf is available
    if ! command -v fzf &>/dev/null; then
        # Fallback to plain list if fzf not installed
        git worktree list
        return
    fi

    # Get worktree list and let user select one
    local selected
    selected=$(git worktree list | fzf --height=40% --reverse --header="Select a worktree to navigate to (ESC to cancel)")

    # If user cancelled (ESC), exit gracefully
    if [[ -z "$selected" ]]; then
        return 0
    fi

    # Extract the path (first column of the output)
    local wt_path
    wt_path=$(echo "$selected" | awk '{print $1}')

    # Print the path for shell integration
    # Users should set up: wtls() { cd "$(wt ls)" }
    echo "$wt_path"
}

# ------------------------------------------------------------------------------
# Command: prune
# ------------------------------------------------------------------------------
# Remove all worktrees except the main repository
cmd_prune() {
    local repo_root
    repo_root="$(get_repo_root)"

    local wt_base
    wt_base="$(get_wt_base "$repo_root")"

    local current_dir
    current_dir="$(pwd)"

    # Check if we're inside a worktree (not the main repo)
    if [[ "$current_dir" == "$wt_base"* ]]; then
        die "cannot prune while inside a worktree. Please cd to the main repo first."
    fi

    # Get all worktrees except the main one
    local worktrees=()
    while IFS= read -r line; do
        local wt_path
        wt_path=$(echo "$line" | awk '{print $1}')
        # Skip the main repo
        if [[ "$wt_path" != "$repo_root" ]]; then
            worktrees+=("$wt_path")
        fi
    done < <(git worktree list)

    if [[ ${#worktrees[@]} -eq 0 ]]; then
        info "No worktrees to remove."
        return 0
    fi

    info "Found ${#worktrees[@]} worktree(s) to remove:"
    for wt in "${worktrees[@]}"; do
        info "  - $wt"
    done
    info ""

    # Remove each worktree
    for wt_path in "${worktrees[@]}"; do
        local wt_name="${wt_path:t}"

        # Get the branch name from git worktree list (it's in brackets)
        local branch_name
        branch_name=$(git worktree list --porcelain | grep -A2 "worktree $wt_path$" | grep "^branch " | sed 's/^branch refs\/heads\///')

        info "Removing worktree: $wt_name"
        git worktree remove "$wt_path" --force 2>/dev/null || true

        # Try to delete the local branch using the actual branch name
        if [[ -n "$branch_name" ]] && branch_exists "$branch_name"; then
            info "Deleting local branch: $branch_name"
            git branch -D "$branch_name" 2>/dev/null || true
        fi
    done

    # Clean up stale metadata
    git worktree prune

    info ""
    info "All worktrees removed. Only main repository remains."
}

# ------------------------------------------------------------------------------
# Command: cd
# ------------------------------------------------------------------------------
# Print the absolute path to a worktree (for use with cd "$(wt cd name)")
cmd_cd() {
    local name="${1:-}"
    validate_name "$name"

    local repo_root
    repo_root="$(get_repo_root)"

    local wt_base
    wt_base="$(get_wt_base "$repo_root")"

    local target_path="${wt_base}/${name}"

    # Check if worktree exists
    if [[ ! -d "$target_path" ]]; then
        die "worktree not found at: $target_path"
    fi

    # Print absolute path to stdout
    echo "$target_path"
}

# ------------------------------------------------------------------------------
# Command: setup
# ------------------------------------------------------------------------------
# Set up wt with all dependencies and shell integration
cmd_setup() {
    info "Setting up wt - Git Worktree Manager..."
    info ""

    # Check for Homebrew
    if ! command -v brew &>/dev/null; then
        die "Homebrew is required but not installed. Install it from https://brew.sh"
    fi

    # Install fzf if not present
    if ! command -v fzf &>/dev/null; then
        info "Installing fzf..."
        brew install fzf
    else
        info "fzf is already installed."
    fi

    # Determine the path to the wt script
    local wt_script="$0"
    # Resolve to absolute path
    if [[ ! "$wt_script" = /* ]]; then
        wt_script="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
    fi

    # Add shell function to .zshrc if not present
    local zshrc="$HOME/.zshrc"
    local marker="# wt - Git Worktree Manager shell integration"

    if grep -q "$marker" "$zshrc" 2>/dev/null; then
        info "Shell integration already exists in ~/.zshrc"
        info "To update, remove the wt block from ~/.zshrc and run setup again."
    else
        info "Adding shell integration to ~/.zshrc..."
        cat >> "$zshrc" << SHELL_EOF

# wt - Git Worktree Manager shell integration
wt() {
    local cmd="\${1:-}"
    case "\$cmd" in
        ls|cd|new)
            local dir
            dir="\$(command $wt_script "\$@")"
            if [[ -n "\$dir" && -d "\$dir" ]]; then
                cd "\$dir"
            fi
            ;;
        *)
            command $wt_script "\$@"
            ;;
    esac
}
SHELL_EOF
        info "Added wt shell function."
    fi

    info ""
    info "Setup complete! Run 'source ~/.zshrc' to activate."
    info ""
    info "Usage:"
    info "  wt ls            - List worktrees and navigate to selection"
    info "  wt cd <name>     - Navigate to a worktree by name"
    info "  wt new <name>    - Create a new worktree and navigate to it"
    info "  wt rm <name>     - Remove a worktree"
    info "  wt help          - Show all commands"
}

# ------------------------------------------------------------------------------
# Command: help
# ------------------------------------------------------------------------------
cmd_help() {
    cat << 'EOF'
wt - Git Worktree Manager

A simple CLI for managing git worktrees. Worktrees are stored in
../<repo-name>-worktrees/<name> relative to your repository.

USAGE:
    wt <command> [args]

COMMANDS:
    new <name>    Create a new worktree and navigate to it
                  - Fetches origin/main
                  - Creates branch <name> from origin/main
                  - Creates worktree at ../<repo>-worktrees/<name>
                  - Copies .env if it exists
                  - Opens in VS Code if available

    rm <name>     Remove a worktree and its local branch
                  - Safely removes the worktree
                  - Deletes the local branch
                  - Never touches remote branches

    ls            List all worktrees interactively and navigate to selection

    cd <name>     Navigate to a worktree by name

    prune         Remove all worktrees (keeps only main repo)

    setup         Install dependencies (fzf) and add shell integration

    help          Show this help message

EXAMPLES:
    wt setup                # First time setup (run once)
    wt new feature-auth     # Create new worktree and cd into it
    wt ls                   # Pick a worktree and cd into it
    wt cd feature-auth      # Navigate to a worktree
    wt rm feature-auth      # Remove the worktree when done
EOF
}

# ------------------------------------------------------------------------------
# Main Dispatch
# ------------------------------------------------------------------------------
main() {
    # Validate we're in a git repo (except for help)
    local command="${1:-help}"

    if [[ "$command" != "help" && "$command" != "--help" && "$command" != "-h" && "$command" != "setup" ]]; then
        validate_git_repo
    fi

    # Dispatch to the appropriate command
    case "$command" in
        new)
            cmd_new "${2:-}"
            ;;
        rm|remove)
            cmd_rm "${2:-}"
            ;;
        ls|list)
            cmd_ls
            ;;
        prune)
            cmd_prune
            ;;
        cd)
            cmd_cd "${2:-}"
            ;;
        setup)
            cmd_setup
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            die "unknown command: $command. Run 'wt help' for usage."
            ;;
    esac
}

# Run main with all arguments
main "$@"
